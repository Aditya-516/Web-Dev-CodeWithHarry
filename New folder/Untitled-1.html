<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Canvas All-in-One Example</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 12px; }
    #controls { margin: 10px 0; }
    canvas { border: 1px solid #ccc; display:block; }
  </style>
</head>
<body>
  <h2>Canvas Example â€” shapes, animation, interaction, save</h2>

  <div id="controls">
    <button id="startStop">Pause</button>
    <button id="clearBtn">Clear</button>
    <button id="saveBtn">Save PNG</button>
  </div>

  <canvas id="canvas"></canvas>

  <script>
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  // Logical size in CSS pixels
  const CSS_WIDTH = 800;
  const CSS_HEIGHT = 400;

  // High-DPI scaling
  function setupCanvas() {
    const ratio = window.devicePixelRatio || 1;
    canvas.width = Math.floor(CSS_WIDTH * ratio);
    canvas.height = Math.floor(CSS_HEIGHT * ratio);
    canvas.style.width = CSS_WIDTH + 'px';
    canvas.style.height = CSS_HEIGHT + 'px';
    ctx.setTransform(ratio, 0, 0, ratio, 0, 0); // scale drawing operations
  }
  setupCanvas();

  // Example state: bouncing circle
  const circle = { x: 100, y: 80, r: 24, vx: 180, vy: 120, color: '#ff6f61' };
  const rects = [
    { x: 300, y: 50, w:120, h:60, color:'#5f9ea0' },
    { x: 460, y: 180, w: 140, h: 90, color:'#ffd166' }
  ];

  let lastTime = performance.now();
  let running = true;

  function drawGrid() {
    ctx.save();
    ctx.lineWidth = 1;
    ctx.strokeStyle = '#eee';
    for(let x=0;x<=CSS_WIDTH;x+=50){
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,CSS_HEIGHT); ctx.stroke();
    }
    for(let y=0;y<=CSS_HEIGHT;y+=50){
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(CSS_WIDTH,y); ctx.stroke();
    }
    ctx.restore();
  }

  function drawScene(delta) {
    ctx.clearRect(0,0,CSS_WIDTH,CSS_HEIGHT);
    drawGrid();

    // draw rectangles (with transforms)
    rects.forEach(r=>{
      ctx.save();
      ctx.fillStyle = r.color;
      ctx.fillRect(r.x, r.y, r.w, r.h);
      ctx.strokeStyle = '#333';
      ctx.strokeRect(r.x, r.y, r.w, r.h);
      ctx.restore();
    });

    // draw path/complex shape
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(600, 50);
    ctx.bezierCurveTo(650, 10, 720, 90, 680, 120);
    ctx.lineWidth = 3;
    ctx.strokeStyle = '#6a0dad';
    ctx.stroke();
    ctx.restore();

    // circle
    ctx.save();
    ctx.beginPath();
    ctx.fillStyle = circle.color;
    ctx.arc(circle.x, circle.y, circle.r, 0, Math.PI*2);
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#333';
    ctx.stroke();
    ctx.restore();

    // sample text
    ctx.save();
    ctx.font = '18px sans-serif';
    ctx.fillStyle = '#333';
    ctx.fillText('Click anywhere to relocate the circle', 10, CSS_HEIGHT - 10);
    ctx.restore();
  }

  function update(dt) {
    // dt in seconds
    circle.x += circle.vx * dt;
    circle.y += circle.vy * dt;

    // bounce on walls (consider radius)
    if(circle.x - circle.r < 0) { circle.x = circle.r; circle.vx *= -1; }
    if(circle.x + circle.r > CSS_WIDTH) { circle.x = CSS_WIDTH - circle.r; circle.vx *= -1; }
    if(circle.y - circle.r < 0) { circle.y = circle.r; circle.vy *= -1; }
    if(circle.y + circle.r > CSS_HEIGHT) { circle.y = CSS_HEIGHT - circle.r; circle.vy *= -1; }

    // simple collisions with rects
    rects.forEach(r=>{
      if (circle.x + circle.r > r.x && circle.x - circle.r < r.x + r.w &&
          circle.y + circle.r > r.y && circle.y - circle.r < r.y + r.h) {
        // basic response: reverse velocity
        circle.vx *= -1.05; circle.vy *= -1.05;
        // move circle out a bit to avoid sticking
        circle.x += circle.vx * dt;
        circle.y += circle.vy * dt;
      }
    });
  }

  function loop(now) {
    const dt = Math.min((now - lastTime) / 1000, 0.05); // clamp dt
    lastTime = now;
    if (running) {
      update(dt);
      drawScene(dt);
    }
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // Interaction: click to move circle
  canvas.addEventListener('click', (ev)=>{
    const rect = canvas.getBoundingClientRect();
    // compute mouse in CSS pixels
    const mx = ev.clientX - rect.left;
    const my = ev.clientY - rect.top;
    circle.x = mx; circle.y = my;
    // randomize velocity a bit
    circle.vx = (Math.random() * 300 - 150);
    circle.vy = (Math.random() * 300 - 150);
  });

  // Controls
  document.getElementById('startStop').addEventListener('click', ()=>{
    running = !running;
    document.getElementById('startStop').textContent = running ? 'Pause' : 'Resume';
  });
  document.getElementById('clearBtn').addEventListener('click', ()=>{
    ctx.clearRect(0,0,CSS_WIDTH,CSS_HEIGHT);
  });

  // Save PNG
  document.getElementById('saveBtn').addEventListener('click', ()=>{
    // toDataURL uses the backing-store pixels, so high-DPI is preserved
    canvas.toBlob((blob)=>{
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'canvas-snapshot.png';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }, 'image/png');
  });

  // Handle resize/repaint on DPR change
  window.addEventListener('resize', () => {
    // if you allow responsive resizing, you'd recalc CSS_WIDTH/CSS_HEIGHT and call setupCanvas()
  });

  </script>
</body>
</html>
